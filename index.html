<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二进制文件损坏工具</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        danger: '#EF4444',
                        dark: '#1F2937',
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .file-drop-area {
                @apply border-2 border-dashed border-gray-300 rounded-lg p-8 text-center transition-all duration-300;
            }
            .file-drop-area.active {
                @apply border-primary bg-blue-50;
            }
            .btn-primary {
                @apply bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-primary/50;
            }
            .btn-secondary {
                @apply bg-secondary hover:bg-secondary/90 text-white font-medium py-2 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-secondary/50;
            }
            .input-field {
                @apply w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition-all duration-200;
            }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <header class="mb-8 text-center">
            <h1 class="text-[clamp(1.8rem,4vw,2.5rem)] font-bold text-dark mb-2">
                <<i class="fa fa-code-fork text-primary mr-2"></</i>二进制文件损坏工具
            </h1>
            <p class="text-gray-600 text-lg">在不修改文件头的情况下，每隔指定字节损坏2字节数据</p>
        </header>

        <main class="bg-white rounded-xl shadow-md p-6 md:p-8 mb-8">
            <!-- 文件上传区域 -->
            <div id="fileDropArea" class="file-drop-area mb-8">
                <<i class="fa fa-cloud-upload text-5xl text-gray-400 mb-4"></</i>
                <p class="text-gray-600 mb-2">拖放文件到这里，或</p>
                <label class="btn-primary inline-block cursor-pointer">
                    <<i class="fa fa-file-o mr-1"></</i> 选择文件
                    <input type="file" id="fileInput" class="hidden" accept="*">
                </label>
                <p id="fileName" class="mt-4 text-gray-500 text-sm hidden"></p>
            </div>

            <!-- 参数设置 -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <div>
                    <label for="headerLength" class="block text-gray-700 font-medium mb-2">
                        文件头长度 (字节)
                    </label>
                    <div class="flex items-center">
                        <input 
                            type="number" 
                            id="headerLength" 
                            class="input-field" 
                            value="512" 
                            min="0"
                            placeholder="不修改的文件头长度"
                        >
                        <span class="ml-2 text-gray-500">字节</span>
                    </div>
                    <p class="text-gray-500 text-sm mt-1">文件开头的这些字节将保持不变</p>
                </div>
                <div>
                    <label for="damageInterval" class="block text-gray-700 font-medium mb-2">
                        损坏间隔 (字节)
                    </label>
                    <div class="flex items-center">
                        <input 
                            type="number" 
                            id="damageInterval" 
                            class="input-field" 
                            value="1024" 
                            min="2"
                            placeholder="每隔多少字节损坏一次"
                        >
                        <span class="ml-2 text-gray-500">字节</span>
                    </div>
                    <p class="text-gray-500 text-sm mt-1">每隔指定字节，损坏接下来的2字节</p>
                </div>
            </div>

            <!-- 处理按钮 -->
            <div class="text-center mb-8">
                <button id="processBtn" class="btn-primary disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    <<i class="fa fa-wrench mr-2"></</i>开始损坏文件
                </button>
            </div>

            <!-- 进度和结果 -->
            <div id="progressArea" class="hidden mb-8">
                <div class="bg-gray-200 rounded-full h-2.5 mb-2">
                    <div id="progressBar" class="bg-primary h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                <p id="progressText" class="text-gray-600 text-center">准备中...</p>
            </div>

            <div id="resultArea" class="hidden mb-8 text-center">
                <div class="p-4 bg-green-50 border border-green-200 rounded-lg mb-4">
                    <<i class="fa fa-check-circle text-secondary text-2xl mb-2"></</i>
                    <h3 class="text-lg font-medium text-gray-800">文件处理完成！</h3>
                    <p id="resultInfo" class="text-gray-600 mt-1"></p>
                </div>
                <button id="downloadBtn" class="btn-secondary">
                    <<i class="fa fa-download mr-2"></</i>下载损坏后的文件
                </button>
            </div>

            <!-- 错误提示 -->
            <div id="errorArea" class="hidden mb-8">
                <div class="p-4 bg-red-50 border border-red-200 rounded-lg">
                    <<i class="fa fa-exclamation-circle text-danger text-xl mb-2"></</i>
                    <p id="errorMessage" class="text-gray-700"></p>
                </div>
            </div>
        </main>

        <footer class="text-center text-gray-500 text-sm">
            <p>二进制文件损坏工具 &copy; 2023 | 在浏览器中本地处理，不会上传您的文件</p>
        </footer>
    </div>

    <script>
        // 获取DOM元素
        const fileDropArea = document.getElementById('fileDropArea');
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const headerLengthInput = document.getElementById('headerLength');
        const damageIntervalInput = document.getElementById('damageInterval');
        const processBtn = document.getElementById('processBtn');
        const progressArea = document.getElementById('progressArea');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const resultArea = document.getElementById('resultArea');
        const resultInfo = document.getElementById('resultInfo');
        const downloadBtn = document.getElementById('downloadBtn');
        const errorArea = document.getElementById('errorArea');
        const errorMessage = document.getElementById('errorMessage');

        // 存储选中的文件
        let selectedFile = null;
        let processedBlob = null;
        let processedFileName = '';

        // 监听文件拖放事件
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, unhighlight, false);
        });

        function highlight() {
            fileDropArea.classList.add('active');
        }

        function unhighlight() {
            fileDropArea.classList.remove('active');
        }

        // 处理文件拖放
        fileDropArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const file = dt.files[0];
            
            if (file) {
                handleFile(file);
            }
        }

        // 处理文件选择
        fileInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                handleFile(this.files[0]);
            }
        });

        // 点击上传区域触发文件选择
        fileDropArea.addEventListener('click', function() {
            fileInput.click();
        });

        // 处理选中的文件
        function handleFile(file) {
            selectedFile = file;
            fileName.textContent = `已选择: ${file.name} (${formatFileSize(file.size)})`;
            fileName.classList.remove('hidden');
            processBtn.disabled = false;
            
            // 重置状态
            resultArea.classList.add('hidden');
            errorArea.classList.add('hidden');
        }

        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 处理文件按钮点击
        processBtn.addEventListener('click', processFile);

        // 处理文件
        function processFile() {
            if (!selectedFile) {
                showError('请先选择一个文件');
                return;
            }

            // 获取参数
            const headerLength = parseInt(headerLengthInput.value, 10);
            const damageInterval = parseInt(damageIntervalInput.value, 10);

            // 验证参数
            if (isNaN(headerLength) || headerLength < 0) {
                showError('文件头长度必须是大于等于0的数字');
                return;
            }

            if (isNaN(damageInterval) || damageInterval < 2) {
                showError('损坏间隔必须是大于等于2的数字');
                return;
            }

            // 重置状态
            resultArea.classList.add('hidden');
            errorArea.classList.add('hidden');
            progressArea.classList.remove('hidden');
            progressBar.style.width = '0%';
            progressText.textContent = '正在读取文件...';

            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    const byteArray = new Uint8Array(arrayBuffer);
                    const fileSize = byteArray.length;

                    // 更新进度
                    updateProgress(20, '正在处理文件...');

                    // 确保文件头长度不超过文件大小
                    const actualHeaderLength = Math.min(headerLength, fileSize);
                    
                    // 计算需要损坏的位置数量
                    const dataSize = fileSize - actualHeaderLength;
                    if (dataSize <= 0) {
                        showError('文件头长度大于或等于文件大小，没有可损坏的数据');
                        return;
                    }

                    // 损坏数据：从文件头之后开始，每隔damageInterval字节，损坏2字节
                    let modifiedCount = 0;
                    
                    for (let i = actualHeaderLength; i < fileSize; i += damageInterval) {
                        // 更新进度
                        const progress = 20 + Math.floor((i / fileSize) * 70);
                        updateProgress(progress, `正在损坏数据... (${modifiedCount}处)`);
                        
                        // 损坏接下来的2字节，确保不超出文件范围
                        for (let j = 0; j < 2 && i + j < fileSize; j++) {
                            // 生成随机字节值 (0-255)
                            byteArray[i + j] = Math.floor(Math.random() * 256);
                            modifiedCount++;
                        }
                    }

                    // 完成处理
                    updateProgress(100, '处理完成！');
                    
                    // 创建处理后的文件
                    processedBlob = new Blob([byteArray], { type: selectedFile.type });
                    const nameParts = selectedFile.name.split('.');
                    if (nameParts.length > 1) {
                        const ext = nameParts.pop();
                        processedFileName = `${nameParts.join('.')}_damaged.${ext}`;
                    } else {
                        processedFileName = `${selectedFile.name}_damaged`;
                    }

                    // 显示结果
                    resultInfo.textContent = `已在文件中损坏 ${modifiedCount/2} 处，共 ${modifiedCount} 字节`;
                    setTimeout(() => {
                        progressArea.classList.add('hidden');
                        resultArea.classList.remove('hidden');
                    }, 500);

                } catch (error) {
                    showError(`处理文件时出错: ${error.message}`);
                }
            };

            reader.onerror = function() {
                showError('读取文件时出错');
            };

            // 读取文件为ArrayBuffer
            reader.readAsArrayBuffer(selectedFile);
        }

        // 更新进度
        function updateProgress(percent, text) {
            progressBar.style.width = `${percent}%`;
            progressText.textContent = text;
        }

        // 显示错误
        function showError(message) {
            progressArea.classList.add('hidden');
            errorMessage.textContent = message;
            errorArea.classList.remove('hidden');
        }

        // 下载处理后的文件
        downloadBtn.addEventListener('click', function() {
            if (processedBlob && processedFileName) {
                const url = URL.createObjectURL(processedBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = processedFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        });
    </script>
</body>
</html>
